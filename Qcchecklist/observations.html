<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Observations</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <script src="libs/jquery-3.6.0.min.js"></script>
  <script src="libs/zxing-browser.min.js"></script>
  <script src="libs/jspdf.umd.min.js"></script>
  <script src="libs/jspdf.plugin.autotable.min.js"></script>
  <script>
    function formatDescription(description) {
      return (
        (description || "")
          .replace(/<[^>]*>/g, "")
          .trim()
          .replace(/\s+/g, " ")
          .replace(/:+(?=\s*\d)/g, "")
          .replace(/:+$/, "")
          .replace(/ (\d+)$/, " - $1")
      );
    }

    const specificOptions = {
    "2.1": ["Present", "Not Present"],
"2.38,2.39,2.40" : ["Matching", "Not Matching", "Not Installed", "Not Applicable"],    "2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,2.10,2.11,2.12,2.13,2.14,2.15,2.16,2.17,2.18,2.19,2.20,2.21,2.22,2.23,2.24,2.25,2.26,2.27,2.28,2.29,2.30,2.31,2.32,2.33,2.34,2.35,2.36,2.37": ["Matching", "Not Matching", "Not Installed"],
    "3.6,14.13": ["Matching", "Not Matching"],
    "3.3,3.4,3.5,3.5.1,3.5.2,3.12,3.13,6.2,6.4,6.7,7.2,8.1,8.2,8.3,8.7.1,8.7.2,8.7.3,8.7.4,9.1-9.6,14.2,14.6,15.2,15.4,15.10,16.2,15.5,15.5.1,3.12,3.13,5.7,6.10,6.11,5.1,8.4,14.8,5.2,5.3,9.7,16.1,16.2,16.3,16.4,5.8,5.7,5.4,15.9": ["Yes", "No"],
    "3.1,3.8,6.8,6.9,8.5,8.6,14.2,14.15.1,14.18,14.18.1,14.19,15.8,14.15,14.17,16.5,5.6,10.4": ["Connected", "Not Connected"],
    "1.1,1.2,3.2,6.1": ["Available", "Not Available"],
    "6.5,8.8": ["Applied", "Not Applied"],
    "4.2,6.6,6.10,7.3,8.7,14.20,16.3,3.9,3.14,5.8,14.14,15.7,6.12,5.9,5.5": ["Routing Done", "Routing Not Done"],
    "4.1,15.6": ["Fixed", "Not Fixed"],
    "6.3,7.1,14.3,14.12,15.3,14.7,3.7,14.15.2": ["Torquing done", "Torquing Not done"],
    "10.1-10.3,14.1,14.11,15.1": ["Installed", "Not Installed"],
    "14.10,14.9": ["Aligned", "Not Aligned"],
    "14.4,14.5": ["Positioning done", "Positioning not done"],
    "14.16": ["Welding done", "Welding Not done"],
    "16.1": ["Earthing done", "Earthing Not done"],
    "15.11,7.4,14.21":["Locked" , "Not Locked"],
    "3.11" :["Cables Connected", "Cables Not Connected"],
    "12.9,12.7,11.4,11.2,11.1,11.1.1,15.2.1" : ["Yes", "No", "Not Applicable"],
    "12.8" :["Fixed", "Not Fixed", "Not Applicable"],
    "12.6,12.2,12.1,11.7,11.10" :["Installed", "Not Installed", "Not Applicable"],
    "12.5,11.6,11.8,11.9,11.11" :["Routing Done", "Routing Not Done", "Not Applicable"], 
    "12.4,11.5,13.1,13.4,13.5,13.6" :["Connected", "Not Connected", "Not Applicable"],
    "12.3" :["Matching", "Not Matching", "Not Applicable"],
    "11.3" :["Applied", "Not Applied", "Not Applicable"],
    "13.2,13.3" :["Verified and ok", "Not ok", "Not Applicable"],
    "3.10" : ["Metal clamps implemented","Metal clamps not implemented"]
    
  };

  </script>
  <style>
    .status-green { background-color: green; color: white; }
    .status-red { background-color: red; color: white; }
    .status-blue { background-color: blue; color: white; }
    .status-yellow { background-color: yellow; color: black; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
    th, td { border: 1px solid black; padding: 10px; text-align: left; }
    th:first-child, td:first-child { text-align: center; } /* Center S.No column */
    img { max-width: 50px; cursor: pointer; }
    .green { color: green; font-weight: bold; }
    .red { color: red; font-weight: bold; }
    .btn-container { margin: 20px 0; text-align: center; }
    .btn-container button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
    .loco-details table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
    .loco-details td { padding: 10px; border: 1px solid black; text-align: left; width: 16%; }
    .loco-details strong { font-weight: bold; }
    .eye-icon { margin-left: 10px; cursor: pointer; color: #007bff; font-size: 18px; }
    .btn-container { display: flex; justify-content: space-between; align-items: center; margin: 20px; }
    #back-btn { background-color: #f44336; color: white; border: none; padding: 10px 20px; cursor: pointer; font-size: 16px; transition: background-color 0.3s ease; }
    #back-btn:hover { background-color: #d32f2f; }
    #convert-pdf-btn { background-color: #4CAF50; color: white; border: none; padding: 10px 20px; cursor: pointer; font-size: 16px; transition: background-color 0.3s ease, opacity 0.3s ease; }
    #convert-pdf-btn:disabled { background-color: #a5d6a7; opacity: 0.6; cursor: not-allowed; }
    #convert-pdf-btn:hover:not(:disabled) { background-color: #388e3c; }
    #go-to-report-btn { background-color: #2196F3; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; font-size: 16px; transition: background-color 0.3s ease; }
    #go-to-report-btn:hover { background-color: #1976D2; }
    #observations-container { margin-bottom: 20px; }
  </style>
</head>
<body>
  <h1>Observations</h1>
  <div class="loco-details">
    <h2>Loco Details</h2>
    <table>
      <tr>
        <td><strong>Loco ID:</strong> <span id="loco-id"></span></td>
        <td><strong>Type:</strong> <span id="loco-type"></span></td>
        <td><strong>Brake Type:</strong> <span id="brake-type"></span></td>
        <td><strong>Railway Division:</strong> <span id="railway-division"></span></td>
        <td><strong>Shed Name:</strong> <span id="shed-name"></span></td>
        <td><strong>Inspection Date:</strong> <span id="inspection-date"></span></td>
      </tr>
    </table>
  </div>
  <div id="observations-container"></div>
  <div class="btn-container">
    <button id="back-btn" onclick="window.history.back()">Back</button>
    <button id="convert-pdf-btn" onclick="createNewReport()">Convert to PDF</button>
    <div id="success-message" style="display: none; color: green; margin-top: 10px;">
      PDF successfully created! Click <strong>Go to Report</strong> to view.
    </div>
    <a href="viewReports.php" id="go-to-report-btn" class="btn-link" style="display: none;">Go to Report</a>
  </div>
  <script>
    const locoDetails = JSON.parse(sessionStorage.getItem('locoDetails'));
    if (locoDetails) {
      const currentDate = new Date();
      const formattedCurrentDate = `${currentDate.getDate().toString().padStart(2, '0')}-${(currentDate.getMonth() + 1).toString().padStart(2, '0')}-${currentDate.getFullYear()}`;
      document.getElementById("loco-id").textContent = locoDetails.loco_id || 'N/A';
      document.getElementById("loco-type").textContent = locoDetails.loco_type || 'N/A';
      document.getElementById("brake-type").textContent = locoDetails.brake_type || 'N/A';
      document.getElementById("railway-division").textContent = locoDetails.railway_division || 'N/A';
      document.getElementById("shed-name").textContent = locoDetails.shed_name || 'N/A';
      document.getElementById("inspection-date").textContent = formattedCurrentDate || 'N/A';
    } else {
      console.error('Loco details not found in sessionStorage');
    }

    async function fetchObservations() {
      let loco_id = locoDetails?.loco_id;
      if (!loco_id) {
        console.error("Loco ID is missing.");
        return { status: 'error', message: 'Loco ID is missing' };
      }
      try {
        const response = await fetch(`fetch_observations.php?loco_id=${loco_id}`);
        const text = await response.text();
        console.log("Raw backend response:", text);
        let data;
        try {
          data = JSON.parse(text);
        } catch (parseError) {
          console.error("JSON parsing error:", parseError, "Raw text:", text);
          return { status: 'error', message: 'Invalid JSON format from backend' };
        }
        if (data.status === 'success' && Array.isArray(data.data)) {
          const filteredData = data.data.filter(row => row.observation_status && row.observation_status.trim() !== '' && row.observation_status.trim() !== 'Select');
          data.data = filteredData;
        }
        return data;
      } catch (error) {
        console.error("Fetch error:", error);
        return { status: 'error', message: error.message || 'Network error occurred' };
      }
    }

    function createObservationsTable(observations) {
      const table = document.createElement("table");
      table.innerHTML = `
        <thead>
          <tr>
            <th style="text-align: center;">S_no</th>
            <th>Description</th>
            <th>Status</th>
            <th>Remarks</th>
            <th>Image</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      const tbody = table.querySelector("tbody");
      const grouped = {};
      observations.forEach(obs => {
        const section = obs.S_no && typeof obs.S_no === 'string' && obs.S_no.includes('.') ? obs.S_no.split('.')[0] : null;
        if (!section) {
          console.warn(`Invalid S_no: ${obs.S_no}`);
          return;
        }
        if (!grouped[section]) grouped[section] = [];
        grouped[section].push(obs);
      });
      let closedPoints = 0;
      const totalPoints = 177;
      Object.keys(grouped).sort((a, b) => Number(a) - Number(b)).forEach(section => {
        const sectionRows = grouped[section];
        if (section !== "1" && section !== "2") {
          let startTime = '', completedTime = '', totalTime = '';
          let startDateObj = null, completedDateObj = null;
          if (sectionRows.length > 0) {
            const parseDate = s => {
              if (!s || typeof s !== 'string') return null;
              const date = new Date(s.replace(' ', 'T'));
              return isNaN(date.getTime()) ? null : date;
            };
            const createdTimes = sectionRows.map(obs => parseDate(obs.created_at)).filter(Boolean);
            const updatedTimes = sectionRows.map(obs => parseDate(obs.updated_at)).filter(Boolean);
            if (createdTimes.length > 0) {
              startDateObj = new Date(Math.min(...createdTimes));
              startTime = startDateObj.toLocaleString();
            }
            if (updatedTimes.length > 0) {
              completedDateObj = new Date(Math.max(...updatedTimes));
              completedTime = completedDateObj.toLocaleString();
            } else if (createdTimes.length > 0) {
              completedDateObj = new Date(Math.max(...createdTimes));
              completedTime = completedDateObj.toLocaleString();
            }
            if (startDateObj && completedDateObj) {
              const ms = completedDateObj - startDateObj;
              const totalSeconds = Math.floor(ms / 1000);
              const hours = Math.floor(totalSeconds / 3600);
              const minutes = Math.floor((totalSeconds % 3600) / 60);
              const seconds = totalSeconds % 60;
              totalTime = `${hours}h ${minutes}m ${seconds}sec`;
            }
          }
          const summaryTr = document.createElement("tr");
          summaryTr.style.background = "#f0f8ff";
          summaryTr.innerHTML = `
            <td colspan="5" style="font-weight:bold;">
              Section ${section} — 
              Start Time: ${startTime || '-'} | 
              Completed Time: ${completedTime || '-'} | 
              Total Time: ${totalTime || '-'}
            </td>
          `;
          tbody.appendChild(summaryTr);
        }
        sectionRows.forEach(obs => {
          if (!obs.observation_status || obs.observation_status.trim() === '' || obs.observation_status.trim() === 'Select') {
            return;
          }
          const formattedDescription = formatDescription(obs.observation_text);
          let statusText = obs.observation_status.trim();
          let statusColor = '';
          switch (statusText) {
            case 'Available':
            case 'Present':
            case 'Yes':
            case 'Routing Done':
            case 'Fixed':
            case 'Secured':
            case 'Installed':
            case 'Connected':
            case 'Aligned':
            case 'Torquing done':
            case 'Positioning done':
            case 'Configured':
            case 'Welding done':
            case 'Earthing done':
            case 'Matching':
            case 'Coating done':
            case 'Locked':
            case 'Applied':
            case 'Cables Connected':
            case 'Metal clamps implemented':
            case 'Not Applicable':
            case 'Verified and ok':
              statusColor = 'green';
              closedPoints++;
              break;
            case 'Not Available':
            case 'Not Present':
            case 'No':
            case 'Not Applied':
            case 'Routing Not Done':
            case 'Not Fixed':
            case 'Not Secured':
            case 'Not Installed':
            case 'Not Connected':
            case 'Not Aligned':
            case 'Torquing Not done':
            case 'Positioning Not done':
            case 'Not Configured':
            case 'Welding not done':
            case 'Earthing Not done':
            case 'Coating Not done':
            case 'Not Locked':
            case 'Not Matching':
            case 'Cables Not Connected':
            case 'Metal clamps not implemented':
            case 'Not ok':
              statusColor = 'red';
              break;
            case 'Not Installed':
              statusColor = 'blue';
              break;
            default:
              statusColor = 'yellow';
          }
          const tr = document.createElement("tr");
          let imageHTML = 'No Image';
          console.log('Image Paths:', obs.image_paths);
          if (obs.image_paths && Array.isArray(obs.image_paths) && obs.image_paths.length > 0) {
            imageHTML = obs.image_paths.map(path =>
              `<img src="${path}" onclick="window.open('${path}', '_blank')" style="max-width: 100px; cursor: pointer; margin-right:5px;" />`
            ).join('');
          } else {
            console.log('No Image Path Provided for S_no:', obs.S_no);
          }
          tr.innerHTML = `
            <td style="text-align: center;">${obs.S_no}</td>
            <td>${formattedDescription}</td>
            <td style="color: ${statusColor};">${statusText}</td>
            <td>${obs.remarks}</td>
            <td>${imageHTML}</td>`;
          tbody.appendChild(tr);
        });
      });
      table.appendChild(tbody);
      const openPoints = totalPoints - closedPoints;
      const summaryTable = document.createElement("table");
      summaryTable.innerHTML = `
        <thead>
          <tr>
            <th>Total Points</th>
            <th>Closed Points</th>
            <th>Open Points</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>${totalPoints}</td>
            <td>${closedPoints}</td>
            <td>${openPoints}</td>
          </tr>
        </tbody>
      `;
      const observationsContainer = document.getElementById("observations-container");
      observationsContainer.appendChild(table);
      observationsContainer.appendChild(summaryTable);
      return table;
    }

    function groupObservationsBySection(observations) {
      if (!Array.isArray(observations)) {
        console.error('Expected an array of observations, but got:', observations);
        return {};
      }
      const grouped = {};
      observations.forEach(observation => {
        const section = observation.S_no && typeof observation.S_no === 'string' && observation.S_no.includes('.') ? observation.S_no.split('.')[0] : null;
        if (!section) {
          console.warn(`Invalid S_no: ${observation.S_no}`);
          return;
        }
        if (!grouped[section]) {
          grouped[section] = [];
        }
        grouped[section].push(observation);
      });
      console.log('Grouped Obs:', grouped);
      return grouped;
    }

    async function renderObservations() {
      const observationsData = await fetchObservations();
      if (observationsData.status === 'success' && Array.isArray(observationsData.data)) {
        createObservationsTable(observationsData.data);
      } else {
        const container = document.getElementById('observations-container');
        container.innerHTML = `<p>${observationsData.message || 'No observations available for this loco.'}</p>`;
      }
    }

    function formatDateString(dateString) {
      if (!dateString || typeof dateString !== 'string') return 'N/A';
      const dateParts = dateString.split('-');
      if (dateParts.length !== 3) return 'N/A';
      return `${dateParts[0]}-${dateParts[1]}-${dateParts[2]}`;
    }

    async function createNewReport() {
      const pdfButton = document.getElementById("convert-pdf-btn");
      pdfButton.disabled = true;
      pdfButton.textContent = "Generating...";
      pdfButton.style.opacity = "0.6";
      try {
        console.log("🚀 Starting createNewReport function...");
        const locoId = document.getElementById("loco-id")?.textContent.trim() || "N/A";
        if (!locoId || locoId === "N/A") {
          alert("⚠️ Loco ID not found. Cannot update completed time.");
          return;
        }
        try {
          const response = await fetch('update_completed_time.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `loco_id=${encodeURIComponent(locoId)}`
          });
          const result = await response.json();
          console.log("🕒 Completed time update response:", result.message);
        } catch (error) {
          console.error("❌ Failed to update completed time:", error);
        }
        const timingsRes = await fetch(`get_loco_timings.php?loco_id=${encodeURIComponent(locoId)}`);
        const timingsData = await timingsRes.json();
        let startTime = "";
        let completedTime = "";
        let totalTime = "";
        if (timingsData.success) {
          startTime = timingsData.start_time;
          completedTime = timingsData.completed_time;
          const start = new Date(startTime);
          const end = new Date(completedTime);
          if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {
            const ms = end - start;
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            totalTime = `${hours}h ${minutes}m ${seconds}sec`;
          } else {
            console.warn("Invalid start or end time for total time calculation");
          }
        } else {
          console.warn("⚠️ Could not fetch timings:", timingsData.message);
        }
        const observationsData = await fetchObservations();
        console.log('📦 Creating PDF with observations:', observationsData);
        const inspectionDate = document.getElementById("inspection-date")?.textContent || "N/A";
        const formattedInspectionDate = formatDateString(inspectionDate);
        const employeeName = localStorage.getItem("employee_name") || "N/A";
        console.log("Retrieved Employee Name:", employeeName);
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();
        const observationsArray = observationsData.data.filter(obs => 
          obs.observation_status && obs.observation_status.trim() !== '' && obs.observation_status.trim() !== 'Select'
        );
        console.log("📋 Observations Array Loaded: ", observationsArray);
        const imagePromises = observationsArray.map(async (obs) => {
          const imageList = [];
          if (obs.image_paths && Array.isArray(obs.image_paths) && obs.image_paths.length > 0) {
            for (const path of obs.image_paths) {
              console.log(`🌄 Loading image: ${path}`);
              const base64 = await getBase64Image(path);
              if (base64) {
                console.log(`✅ Successfully converted image to base64: ${path}`);
                imageList.push(base64);
              } else {
                console.warn(`⚠️ Failed to convert image to base64: ${path}`);
              }
            }
          }
          return { S_no: obs.S_no, images: imageList };
        });
        console.log("📤 Initiating Image Loading...");
        const imageDataArray = await Promise.all(imagePromises);
        console.log("✅ Images Loaded Successfully:", imageDataArray);
        const imageData = {};
        imageDataArray.forEach(entry => {
          imageData[entry.S_no] = entry.images;
        });
        console.log("📁 Processed Image Data:", imageData); 
        const logoPath = 'hbl_logo.jpg';
        const logoBase64 = await getBase64Image(logoPath);
        const pageHeight = pdf.internal.pageSize.height;
        const footerHeight = 15;
        const bottomMargin = 20;
        let finalY = 10;

        if (logoBase64) {
          const logoWidth = 30;
          const logoHeight = 20;
          const pageWidth = pdf.internal.pageSize.width;
          const xPosition = pageWidth - logoWidth - 10;
          pdf.addImage(logoBase64, 'JPEG', xPosition, finalY, logoWidth, logoHeight);
        }
        pdf.setFont("helvetica", "bold");
        pdf.setFontSize(14);
        pdf.text("HBL Engineering Limited", pdf.internal.pageSize.width / 2, finalY + 5, { align: "center" });
        pdf.setFont("helvetica", "normal");
        pdf.setFontSize(12);
        pdf.text("Electronics Group", pdf.internal.pageSize.width / 2, finalY + 12, { align: "center" });
        pdf.setFont("helvetica", "bold");
        pdf.text("In-Process QC CheckList for Onboard Kavach Installation", pdf.internal.pageSize.width / 2, finalY + 20, { align: "center" });
        pdf.setFont("helvetica", "normal");
        pdf.text(`QC Engineer Name: ${employeeName}`, 10, finalY + 26);
        pdf.text("v1.1", pdf.internal.pageSize.width - 10, finalY + 26, { align: "right" });
        pdf.line(10, finalY + 28, pdf.internal.pageSize.width - 10, finalY + 28);
        finalY += 30;

        const locoDetailsRow = [
          document.getElementById("loco-id")?.textContent || "N/A",
          document.getElementById("loco-type")?.textContent || "N/A",
          document.getElementById("brake-type")?.textContent || "N/A",
          document.getElementById("railway-division")?.textContent || "N/A",
          document.getElementById("shed-name")?.textContent || "N/A",
          document.getElementById("inspection-date")?.textContent || "N/A"
        ];
        pdf.autoTable({
          head: [["Loco ID", "Loco Type", "Brake Type", "Railway Division", "Shed Name", "Inspection Date"]],
          body: [locoDetailsRow],
          startY: finalY,
          margin: { right: 10 },
          theme: "grid",
          styles: {
            fontSize: 10,
            cellPadding: 2,
            overflow: 'linebreak',
            lineWidth: 0.1,
            lineColor: [0, 0, 0],
            halign: 'center',
            valign: 'middle'
          },
          headStyles: {
            textColor: [255, 255, 255],
            fillColor: [0, 102, 204],
            lineWidth: 0.5,
            lineColor: [0, 0, 0]
          },
          bodyStyles: {
            lineWidth: 0.5,
            lineColor: [0, 0, 0],
            valign: 'middle',
            textColor: [0, 0, 0]
          },
          columnStyles: {
            0: { cellWidth: 31 },
            1: { cellWidth: 31 },
            2: { cellWidth: 31 },
            3: { cellWidth: 31 },
            4: { cellWidth: 31 },
            5: { cellWidth: 30 }
          }
        });
        finalY = pdf.lastAutoTable.finalY + 10;

        if (finalY > pageHeight - footerHeight - bottomMargin - 40) {
          pdf.addPage();
          finalY = 10;
        }

        const totalPointsFixed = 177;
        const closedPoints = observationsArray.filter(obs =>
          ["Available", "Present", "Yes", "Routing Done", "Fixed", "Secured", "Installed", "Connected", "Aligned", "Torquing done", "Positioning done", "Configured", "Welding done", "Earthing done", "Matching", "Not Applicable", "Coating done", "Applied", "Cables Connected", "Metal clamps implemented", "Locked","Verified and ok"].includes(obs.observation_status.trim())
        ).length;
        const openPoints = totalPointsFixed - closedPoints;
        console.log("Total Points:", totalPointsFixed);
        console.log("Closed Points:", closedPoints);
        console.log("Open Points:", openPoints);
        console.log("Observations Array Length:", observationsArray.length);
        const completionStatus = (openPoints === 0) ? "Completed" : "NotCompleted";
        console.log("Completion Status:", completionStatus);
        console.log("Observations with statuses:", observationsArray.map(obs => ({
          S_no: obs.S_no,
          status: obs.observation_status
        })));
        const fileName = await getVersionedFileName(locoId, formattedInspectionDate, completionStatus);
        if (!fileName) {
          alert("File name is required to save the report.");
          return;
        }
        pdf.autoTable({
          startY: finalY,
          head: [["Total Points", "Closed Points", "Open Points"]],
          body: [[totalPointsFixed, closedPoints, openPoints]],
          margin: { right: 10 },
          theme: "grid",
          styles: {
            fontSize: 10,
            cellPadding: 2,
            overflow: 'linebreak',
            lineWidth: 0.1,
            lineColor: [0, 0, 0],
            halign: 'center',
            valign: 'middle'
          },
          headStyles: {
            textColor: [255, 255, 255],
            fillColor: [0, 102, 204],
            lineWidth: 0.5,
            lineColor: [0, 0, 0]
          },
          bodyStyles: {
            lineWidth: 0.5,
            lineColor: [0, 0, 0],
            valign: 'middle',
            textColor: [0, 0, 0]
          },
          columnStyles: {
            0: { cellWidth: 61 },
            1: { cellWidth: 62 },
            2: { cellWidth: 62 }
          }
        });
        finalY = pdf.lastAutoTable.finalY + 10;

        pdf.autoTable({
          startY: finalY,
          head: [["Start Date & Time", "Completed Date & Time", "Total Time"]],
          body: [[startTime, completedTime, totalTime]],
          margin: { right: 10 },
          theme: "grid",
          styles: {
            fontSize: 10,
            cellPadding: 2,
            overflow: 'linebreak',
            lineWidth: 0.1,
            lineColor: [0, 0, 0],
            halign: 'center',
            valign: 'middle'
          },
          headStyles: {
            textColor: [255, 255, 255],
            fillColor: [0, 102, 204],
            lineWidth: 0.5,
            lineColor: [0, 0, 0]
          },
          bodyStyles: {
            lineWidth: 0.5,
            lineColor: [0, 0, 0],
            valign: 'middle',
            textColor: [0, 0, 0]
          },
          columnStyles: {
            0: { cellWidth: 61 },
            1: { cellWidth: 62 },
            2: { cellWidth: 62 }
          }
        });
        finalY = pdf.lastAutoTable.finalY + 10;

        pdf.autoTable({
          startY: finalY,
          head: [],
          body: [["", "", ""]],
          margin: { right: 10 },
          theme: "grid",
          styles: {
            fontSize: 10,
            cellPadding: 2,
            overflow: 'linebreak',
            lineWidth: 0.1,
            lineColor: [0, 0, 0],
            halign: 'center',
            valign: 'middle'
          },
          columnStyles: {
            0: { cellWidth: 61 },
            1: { cellWidth: 62 },
            2: { cellWidth: 62 }
          },
          bodyStyles: {
            lineWidth: 0.5,
            lineColor: [0, 0, 0],
            valign: 'middle',
            textColor: [0, 0, 0]
          },
          didDrawCell: function (data) {
            if (data.row.section === 'body') {
              const { column, cell } = data;
              if (column.index === 0) {
                pdf.setFont("helvetica", "bold");
                pdf.setFontSize(10);
                pdf.text("Completion Status", cell.x + 5, cell.y + cell.height / 2 + 3);
              }
              const boxSize = 6;
              const imgSize = 5;
              const offsetY = cell.height / 2 - boxSize / 2;
              if (column.index === 1) {
                const boxX = cell.x + 10;
                const boxY = cell.y + offsetY;
                pdf.setLineWidth(0.5);
                pdf.rect(boxX, boxY, boxSize, boxSize);
                if (openPoints === 0) {
                  pdf.addImage("tick.png", "PNG", boxX + 0.5, boxY + 0.5, imgSize, imgSize);
                }
                pdf.setFont("helvetica", "normal");
                pdf.setFontSize(10);
                pdf.text("Completed", boxX + boxSize + 6, boxY + boxSize - 1);
              }
              if (column.index === 2) {
                const boxX = cell.x + 10;
                const boxY = cell.y + offsetY;
                pdf.setLineWidth(0.5);
                pdf.rect(boxX, boxY, boxSize, boxSize);
                if (openPoints !== 0) {
                  pdf.addImage("cross.png", "PNG", boxX + 0.5, boxY + 0.5, imgSize, imgSize);
                }
                pdf.setFont("helvetica", "normal");
                pdf.setFontSize(10);
                pdf.text("Not Completed", boxX + boxSize + 6, boxY + boxSize - 1);
              }
            }
          }
        });
        finalY = pdf.lastAutoTable.finalY + 10;

        function calculateRowHeight(row, sectionId) {
          const imagesCount = imageData[row.S_no]?.length || 0;
          const baseHeight = Math.max(30, imagesCount * 28);
          const cellPadding = 2 * 2;
          const lineWidth = 0.1 * 2;
          const textHeight = 10;
          const totalHeight = baseHeight + cellPadding + lineWidth + textHeight;
          console.log(`Row ${row.S_no} height: ${totalHeight}px (base: ${baseHeight}, padding: ${cellPadding}, line: ${lineWidth}, text: ${textHeight})`);
          return totalHeight;
        }

        function getFittingRows(rows, availableHeight, sectionId, forceFirstOne = false) {
          const headHeight = 10 + (2 * 2) + (0.5 * 2);
          let totalHeight = headHeight;
          const fittingRows = [];
          
          for (let i = 0; i < rows.length; i++) {
            const rowHeight = calculateRowHeight(rows[i], sectionId);
            if (totalHeight + rowHeight <= availableHeight || (forceFirstOne && i === 0 && sectionId === "2")) {
              fittingRows.push(rows[i]);
              totalHeight += rowHeight;
            } else {
              break;
            }
            if (!forceFirstOne && fittingRows.length >= 1) break;
          }
          console.log(`Fitting rows for section ${sectionId}: ${fittingRows.length}, Total height: ${totalHeight}px, Available: ${availableHeight}px, Force: ${forceFirstOne}`);
          return fittingRows;
        }

        const groupedObservations = groupObservationsBySection(observationsData.data);
        console.log('Grouped Observations:', groupedObservations);
        for (let sectionId in groupedObservations) {
          const sectionObservations = groupedObservations[sectionId];
          const parseDate = s => {
            if (!s || typeof s !== 'string') return null;
            const [datePart, timePart] = s.split(" ");
            if (!datePart || !timePart) return null;
            const date = new Date(`${datePart}T${timePart}`);
            return isNaN(date.getTime()) ? null : date;
          };
          let sectionStartTime = "-", sectionCompletedTime = "-", sectionTotalTime = "-";
          let sectionStartObj = null, sectionCompletedObj = null;
          if (sectionId !== "1" && sectionId !== "2") {
            const createdTimes = sectionObservations.map(obs => parseDate(obs.created_at)).filter(Boolean);
            const updatedTimes = sectionObservations.map(obs => parseDate(obs.updated_at)).filter(Boolean);
            if (createdTimes.length > 0) {
              sectionStartObj = new Date(Math.min(...createdTimes));
              sectionStartTime = sectionStartObj.toLocaleString();
            }
            if (updatedTimes.length > 0) {
              sectionCompletedObj = new Date(Math.max(...updatedTimes));
              sectionCompletedTime = sectionCompletedObj.toLocaleString();
            } else if (createdTimes.length > 0) {
              sectionCompletedObj = new Date(Math.max(...createdTimes));
              sectionCompletedTime = sectionCompletedObj.toLocaleString();
            }
            if (sectionStartObj && sectionCompletedObj) {
              const ms = sectionCompletedObj - sectionStartObj;
              const totalSeconds = Math.floor(ms / 1000);
              const hours = Math.floor(totalSeconds / 3600);
              const minutes = Math.floor((totalSeconds % 3600) / 60);
              const seconds = totalSeconds % 60;
              sectionTotalTime = `${hours}h ${minutes}m ${seconds}sec`;
            }
          }
          const sectionCaptions = {
            1: "1.0 DOCUMENT VERIFICATION",
            2: "2.0 VERIFICATION OF SERIAL NUMBERS OF EQUIPMENT AS PER IC",
            3: "3.0 LOCO KAVACH",
            4: "4.0 EMI FILTER BOX",
            5: "5.0 RIB AND CAB INPUT BOX",
            6: "6.0 DMI (LP-OCIP)",
            7: "7.0 RFID PS UNIT",
            8: "8.0 LOCO ANTENNA AND GPS/GSM ANTENNA",
            9: "9.0 PNEUMATIC FITTINGS AND EP VALVE COCKS",
            10: "10.0 PRESSURE SENSORS",
            11: "11.0 IRU FAVIELY UNITS FIXING FOR E70 TYPE LOCO",
            12: "12.0 PSJB AND TPM UNITS FIXING FOR CCB TYPE LOCO",
            13: "13.0 IRAB (Indian Railway Air-Break)",
            14: "14.0 PG AND SPEEDO METER UNITS",
            15: "15.0 RFID READER ASSEMBLY",
            16: "16.0 AUTO HORN INSTALLATION",
            17: "17.0 RADIO POWER"
          };
          const sectionCaption = sectionCaptions[sectionId] || `Observations for Section ${sectionId}`;
          const sectionHeaderHeight = 8;

          pdf.setFont("helvetica", "bold")
            .setFontSize(12)
            .setTextColor(0, 0, 255)
            .text(sectionCaption, 10, finalY);
          finalY += sectionHeaderHeight;

          if (sectionId !== "1" && sectionId !== "2") {
            pdf.autoTable({
              startY: finalY,
              margin: { right: 10 },
              head: [["Start Date & Time", "Completed Date & Time", "Total Time"]],
              body: [[sectionStartTime, sectionCompletedTime, sectionTotalTime]],
              theme: "grid",
              styles: {
                fontSize: 10,
                cellPadding: 2,
                overflow: 'linebreak',
                lineWidth: 0.1,
                lineColor: [0, 0, 0],
                halign: 'center',
                valign: 'middle'
              },
              headStyles: {
                textColor: [255, 255, 255],
                fillColor: [0, 102, 204],
                lineWidth: 0.5,
                lineColor: [0, 0, 0]
              },
              bodyStyles: {
                lineWidth: 0.5,
                lineColor: [0, 0, 0],
                valign: 'middle',
                textColor: [0, 0, 0]
              },
              columnStyles: {
                0: { cellWidth: 61 },
                1: { cellWidth: 62 },
                2: { cellWidth: 62 }
              }
            });
            finalY = pdf.lastAutoTable.finalY + 4;
          }

          const imageData = {};
          for (const obs of sectionObservations) {
            imageData[obs.S_no] = [];
            if (obs.image_paths && Array.isArray(obs.image_paths) && obs.image_paths.length > 0) {
              for (const imgPath of obs.image_paths) {
                const base64 = await getBase64Image(imgPath);
                if (base64) {
                  imageData[obs.S_no].push(base64);
                }
              }
            }
          }
          const rows = sectionObservations.map(obs => {
            const imagesCount = imageData[obs.S_no]?.length || 0;
            const calculatedHeight = Math.max(30, imagesCount * 28);
            return {
              S_no: obs.S_no,
              Description: formatDescription(obs.observation_text),
              Status: obs.observation_status,
              Remarks: obs.remarks,
              imageBase64: imageData[obs.S_no][0] || "",
              calculatedHeight
            };
          });
          let availableHeight = pageHeight - finalY - footerHeight - bottomMargin;
          if (availableHeight < sectionHeaderHeight + bottomMargin + 30) {
            pdf.addPage();
            finalY = 10;
            availableHeight = pageHeight - finalY - footerHeight - bottomMargin;
          }
          pdf.autoTable({
            startY: finalY,
            margin: { right: 10 },
            head: [["S.No", "Description", "Status", "Remarks", ...(sectionId === "1" ? [] : ["Image"])]],
            body: rows.map(r => [
              r.S_no,
              r.Description,
              r.Status,
              r.Remarks,
              ...(sectionId === "1" ? [] : [{ content: "", raw: r.imageBase64, styles: { minCellHeight: r.calculatedHeight } }])
            ]),
            theme: "grid",
            showHead: 'everyPage',
            rowPageBreak: "avoid",
            styles: {
              fontSize: 10,
              cellPadding: 2,
              overflow: 'linebreak',
              lineWidth: 0.1,
              lineColor: [0, 0, 0],
              halign: 'center',
              valign: 'middle'
            },
            headStyles: {
              textColor: [255, 255, 255],
              fillColor: [0, 102, 204],
              lineWidth: 0.5,
              lineColor: [0, 0, 0]
            },
            bodyStyles: {
              lineWidth: 0.5,
              lineColor: [0, 0, 0],
              valign: 'middle',
              textColor: [0, 0, 0]
            },
            columnStyles: {
              0: { cellWidth: sectionId === "1" ? 25 : 22, halign: 'center' }, // S.No centered
              1: { cellWidth: sectionId === "1" ? 65 : 56, halign: 'left' }, // Description
              2: { cellWidth: sectionId === "1" ? 30 : 26, halign: 'left' }, // Status
              3: { cellWidth: sectionId === "1" ? 65 : 56, halign: 'left' }, // Remarks
              4: { cellWidth: sectionId === "1" ? 0 : 25, halign: 'right' } // Image
            },
            didParseCell: function (data) {
              if (data.row.section === 'body' && data.column.index === 2) {
                const statusText = String(data.cell.raw).trim();
                const s_no = String(data.row.raw[0]);
                function matchesSno(sno, pattern) {
                  return pattern.split(',').some(part => {
                    if (part.includes('-')) {
                      const [start, end] = part.split('-').map(p => parseFloat(p));
                      const num = parseFloat(sno);
                      return !isNaN(num) && num >= start && num <= end;
                    }
                    return sno === part.trim();
                  });
                }
                let textColor = [0, 0, 0];
                for (const key in specificOptions) {
                  if (matchesSno(s_no, key)) {
                    const values = specificOptions[key];
                    if (values.includes(statusText)) {
                      if (statusText.includes("Not") || statusText.includes("No")) {
                        textColor = [255, 0, 0];
                      } else if (statusText.includes("NA")) {
                        textColor = [128, 128, 128];
                      } else {
                        textColor = [0, 128, 0];
                      }
                    }
                  }
                }
                data.cell.styles.textColor = textColor;
              }
            },
            didDrawCell: function (data) {
              try {
                if (data.row.section === 'body' && data.column.index === 4) {
                  const row = rows[data.row.index];
                  if (!row || !row.S_no) {
                    console.warn(`No valid row or S_no at index ${data.row.index}`);
                    return;
                  }
                  const S_no = row.S_no;
                  const images = Array.isArray(imageData[S_no]) ? imageData[S_no] : [];
                  if (images.length === 0) {
                    console.log(`No images for S_no: ${S_no}`);
                    return;
                  }
                  const imgX = data.cell.x + 2;
                  let imgY = data.cell.y + 2;
                  const maxWidth = data.cell.width - 4;
                  const maxCellHeight = Math.max(10, data.cell.height - 4);
                  const individualHeight = Math.min(25, maxCellHeight / images.length - 2);
                  for (const base64 of images) {
                    if (typeof base64 === 'string' && base64.startsWith('data:image/jpeg;base64,')) {
                      pdf.addImage(base64, 'JPEG', imgX, imgY, maxWidth, individualHeight);
                      imgY += individualHeight + 2;
                    } else {
                      console.warn(`Invalid base64 image for S_no: ${S_no}`);
                    }
                  }
                }
              } catch (error) {
                console.error("🚨 Error in didDrawCell function:", error.message, error.stack);
              }
            },
            didCalculateCellHeight: function (data) {
              if (data.row.section === 'body' && data.column.index === 4) {
                const images = Array.isArray(imageData[data.row.raw[0]]) ? imageData[data.row.raw[0]] : [];
                if (images.length === 0) return;
                const imageHeight = 25;
                const spacing = 2;
                const padding = 6;
                const totalImageHeight = (imageHeight + spacing) * images.length - spacing;
                const requiredHeight = totalImageHeight + padding;
                if (requiredHeight > data.cell.height) {
                  data.cell.height = requiredHeight;
                }
              }
            }
          });
          finalY = pdf.lastAutoTable.finalY + 10;
          if (finalY > pageHeight - footerHeight - bottomMargin) {
            pdf.addPage();
            finalY = 10;
          }
        }
        const totalPages = pdf.internal.getNumberOfPages();
        pdf.setPage(totalPages);
        const tableEndY = pdf.lastAutoTable.finalY || (pdf.internal.pageSize.height / 2);
        const noteY = tableEndY + 10;
        pdf.setFont("helvetica", "bold").setFontSize(12);
        pdf.text(
          "Note : This QC report is generated by the system and does not need a physical signature.",
          pdf.internal.pageSize.width / 2,
          noteY,
          { align: "center" }
        );
        const totalPagesFinal = pdf.internal.getNumberOfPages();
        for (let i = 1; i <= totalPagesFinal; i++) {
          pdf.setPage(i)
            .setFont("helvetica", "normal")
            .setFontSize(10);
          pdf.text("EG-IC-FT-34 Rev3", 10, pdf.internal.pageSize.height - 10);
          pdf.text(
            `Page ${i} of ${totalPagesFinal}`,
            pdf.internal.pageSize.width - 10,
            pdf.internal.pageSize.height - 10,
            { align: "right" }
          );
        }
        const pdfBlob = pdf.output('blob');
        await uploadPDF(pdfBlob, fileName);
      } finally {
        pdfButton.disabled = false;
        pdfButton.textContent = "Convert to PDF";
        pdfButton.style.opacity = "1";
      }
    }

    async function getVersionedFileName(locoId, inspectionDate, completionStatus) {
      try {
        const response = await fetch(`getNextVersion.php?loco_id=${locoId}`);
        const data = await response.json();
        if (data.success) {
          const version = data.version;
          return `${locoId}_${inspectionDate}_Report_${completionStatus}_Version-${version}.pdf`;
        } else {
          alert('Error fetching version: ' + data.message);
          return null;
        }
      } catch (error) {
        console.error('Error fetching version:', error);
        alert('Error fetching version');
        return null;
      }
    }

    async function getBase64Image(imgUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = imgUrl;
        img.onload = function () {
          const canvas = document.createElement("canvas");
          const maxWidth = 100;
          const maxHeight = 100;
          let width = img.width;
          let height = img.height;
          if (width > height) {
            if (width > maxWidth) {
              height *= maxWidth / width;
              width = maxWidth;
            }
          } else {
            if (height > maxHeight) {
              width *= maxHeight / height;
              height = maxHeight;
            }
          }
          const scale = 6;
          canvas.width = width * scale;
          canvas.height = height * scale;
          const ctx = canvas.getContext("2d");
          ctx.scale(scale, scale);
          ctx.drawImage(img, 0, 0, width, height);
          const base64 = canvas.toDataURL("image/jpeg", 1.0);
          resolve(base64);
        };
        img.onerror = function (error) {
          console.error("Error loading image:", imgUrl, error);
          resolve(null);
        };
      });
    }

    async function fetchReports() {
      const username = localStorage.getItem("user_id");
      if (!username) {
        alert("User ID not found. Cannot fetch reports.");
        return;
      }
      try {
        const response = await fetch(`fetchReports.php?user_id=${username}`);
        const text = await response.text();
        console.log("Raw response:", text);
        const data = JSON.parse(text);
        if (data.success) {
          console.log("Reports:", data.reports);
          displayReports(data.reports);
        } else {
          alert("Error: " + data.message);
        }
      } catch (error) {
        console.error("Error fetching reports:", error);
        alert("An error occurred while fetching reports.");
      }
    }

    function displayReports(reports) {
      const reportContainer = document.getElementById("reportList");
      if (!reportContainer) {
        console.error("Element with ID 'reportList' not found!");
        return;
      }
      reportContainer.innerHTML = "";
      if (reports.length === 0) {
        reportContainer.innerHTML = "<p>No reports available.</p>";
        return;
      }
      reports.forEach(report => {
        const reportItem = document.createElement("div");
        reportItem.innerHTML = `
          <p><strong>Uploaded By:</strong> ${report.user_id}</p>
          <p><strong>File:</strong> <a href="/Uploads/reports/${report.file_name}" target="_blank">${report.file_name}</a></p>
          <p><strong>Uploaded On:</strong> ${report.upload_date}</p>
          <hr>
        `;
        reportContainer.appendChild(reportItem);
      });
    }

    document.addEventListener("DOMContentLoaded", fetchReports);
    async function uploadPDF(pdfBlob, fileName) {
      const formData = new FormData();
      let cleanFileName = fileName.trim();
      if (!cleanFileName.toLowerCase().endsWith(".pdf")) {
        cleanFileName += ".pdf";
      }
      formData.append('file', pdfBlob, cleanFileName);
      const userId = localStorage.getItem("user_id");
      if (userId) {
        formData.append('user_id', userId);
      } else {
        alert("User ID is missing. Cannot upload report.");
        return;
      }
      const response = await fetch('uploadReport.php', { method: 'POST', body: formData });
      const data = await response.json();
      if (data.success) {
        alert(data.message);
        const successMessage = document.getElementById("success-message");
        const goToReportBtn = document.getElementById("go-to-report-btn");
        if (successMessage && goToReportBtn) {
          successMessage.style.display = "block";
          goToReportBtn.style.display = "inline-block";
        }
      } else {
        alert("Error uploading report: " + data.message);
      }
    }

    renderObservations();
  </script>
</body>
</html>